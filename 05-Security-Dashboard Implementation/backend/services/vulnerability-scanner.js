const https = require('https');
const http = require('http');

class VulnerabilityScanner {
    constructor() {
        this.commonVulnerabilities = [
            'missing_https',
            'weak_ssl',
            'missing_security_headers',
            'exposed_directories',
            'outdated_software',
            'weak_authentication'
        ];
    }
    
    async scanWebsite(url) {
        const results = {
            url: url,
            timestamp: new Date().toISOString(),
            vulnerabilities: [],
            securityScore: 100,
            recommendations: []
        };
        
        try {
            // Check HTTPS
            await this.checkHTTPS(url, results);
            
            // Check Security Headers
            await this.checkSecurityHeaders(url, results);
            
            // Check SSL Configuration
            await this.checkSSLConfiguration(url, results);
            
            // Calculate final security score
            results.securityScore = Math.max(0, results.securityScore);
            results.riskLevel = this.calculateRiskLevel(results.securityScore);
            
        } catch (error) {
            console.error('Scanning error:', error);
            results.error = error.message;
        }
        
        return results;
    }
    
    async checkHTTPS(url, results) {
        if (!url.startsWith('https://')) {
            results.vulnerabilities.push({
                type: 'missing_https',
                severity: 'HIGH',
                description: 'Website does not use HTTPS encryption',
                impact: 'Data transmission is not encrypted'
            });
            results.securityScore -= 30;
            results.recommendations.push('Enable HTTPS/SSL certificate');
        }
    }
    
    async checkSecurityHeaders(url, results) {
        return new Promise((resolve, reject) => {
            const client = url.startsWith('https://') ? https : http;
            
            client.get(url, (res) => {
                const headers = res.headers;
                
                // Check for important security headers
                const securityHeaders = [
                    'strict-transport-security',
                    'x-frame-options',
                    'x-content-type-options',
                    'x-xss-protection',
                    'content-security-policy'
                ];
                
                securityHeaders.forEach(header => {
                    if (!headers[header]) {
                        results.vulnerabilities.push({
                            type: 'missing_security_header',
                            severity: 'MEDIUM',
                            description: `Missing ${header} header`,
                            impact: 'Reduced protection against various attacks'
                        });
                        results.securityScore -= 10;
                        results.recommendations.push(`Implement ${header} header`);
                    }
                });
                
                resolve();
            }).on('error', (err) => {
                reject(err);
            });
        });
    }
    
    calculateRiskLevel(score) {
        if (score >= 80) return 'LOW';
        if (score >= 60) return 'MEDIUM';
        if (score >= 40) return 'HIGH';
        return 'CRITICAL';
    }
    
    generateReport(scanResults) {
        return {
            summary: {
                url: scanResults.url,
                scannedAt: scanResults.timestamp,
                securityScore: scanResults.securityScore,
                riskLevel: scanResults.riskLevel,
                vulnerabilitiesFound: scanResults.vulnerabilities.length
            },
            vulnerabilities: scanResults.vulnerabilities,
            recommendations: scanResults.recommendations,
            nextScanRecommended: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
        };
    }
}

module.exports = VulnerabilityScanner;