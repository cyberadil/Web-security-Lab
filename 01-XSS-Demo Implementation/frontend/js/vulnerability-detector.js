/**
 * Vulnerability Detector Module
 * Provides real-time detection of security vulnerabilities in user inputs
 * Created for Web Security Lab
 */

class VulnerabilityDetector {
    constructor() {
        this.vulnerabilityPatterns = {
            xss: [
                /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/i,
                /<img[^>]+\bon\w+\s*=/i,
                /<\w+[^>]+\bon\w+\s*=/i,
                /javascript\s*:/i,
                /data\s*:[^,]*base64/i,
                /expression\s*\(/i,
                /eval\s*\(/i,
                /alert\s*\(/i,
                /document\.cookie/i,
                /document\.location/i,
                /document\.referrer/i,
                /document\.write/i,
                /window\.location/i,
                /\.innerHTML/i,
                /\.outerHTML/i
            ],
            sql: [
                /'\s*OR\s*'1'\s*=\s*'1/i,
                /'\s*OR\s*1\s*=\s*1/i,
                /'\s*OR\s*'\w+'\s*=\s*'\w+/i,
                /'\s*OR\s*\d+\s*=\s*\d+/i,
                /'\s*;\s*DROP\s+TABLE/i,
                /'\s*;\s*DELETE\s+FROM/i,
                /'\s*;\s*INSERT\s+INTO/i,
                /'\s*;\s*UPDATE\s+/i,
                /'\s*;\s*SELECT\s+/i,
                /UNION\s+SELECT/i,
                /UNION\s+ALL\s+SELECT/i,
                /SLEEP\s*\(/i,
                /BENCHMARK\s*\(/i,
                /WAITFOR\s+DELAY/i
            ],
            csrf: [
                /<form[^>]*action\s*=\s*["'](?!https?:\/\/localhost)/i,
                /<img[^>]*src\s*=\s*["'](?!https?:\/\/localhost)/i,
                /<iframe[^>]*src\s*=\s*["'](?!https?:\/\/localhost)/i
            ]
        };

        this.scoreValues = {
            xss: 10,
            sql: 15,
            csrf: 20
        };

        this.init();
    }

    /**
     * Initialize the detector
     */
    init() {
        // Add event listeners to all input fields
        this.addInputListeners();
        
        // Initialize vulnerability counter
        this.initVulnerabilityCounter();
        
        console.log('[VulnerabilityDetector] Initialized');
    }

    /**
     * Add input event listeners to detect vulnerabilities in real-time
     */
    addInputListeners() {
        // Find all input fields, textareas, and contenteditable elements
        const inputElements = document.querySelectorAll('input[type="text"], input[type="search"], textarea, [contenteditable="true"]');
        
        inputElements.forEach(input => {
            // Skip if already initialized
            if (input.dataset.vulnerabilityDetectorInitialized) return;
            
            // Mark as initialized
            input.dataset.vulnerabilityDetectorInitialized = 'true';
            
            // Add input event listener
            input.addEventListener('input', (e) => {
                this.detectVulnerabilities(e.target);
            });
            
            // Add focus event listener to reset styles
            input.addEventListener('focus', (e) => {
                this.resetInputStyles(e.target);
            });
        });
    }

    /**
     * Initialize vulnerability counter in localStorage
     */
    initVulnerabilityCounter() {
        // Check if counter exists in localStorage
        if (!localStorage.getItem('seclab_vulnerability_counter')) {
            // Initialize counter
            const counter = {
                xss: 0,
                sql: 0,
                csrf: 0,
                total: 0,
                lastReset: new Date().toISOString()
            };
            
            localStorage.setItem('seclab_vulnerability_counter', JSON.stringify(counter));
        }
    }

    /**
     * Detect vulnerabilities in input value
     */
    detectVulnerabilities(inputElement) {
        const value = inputElement.value || inputElement.textContent || '';
        
        if (!value.trim()) {
            this.resetInputStyles(inputElement);
            return;
        }
        
        // Check for vulnerabilities
        const vulnerabilities = this.checkVulnerabilities(value);
        
        // Update input styles based on detected vulnerabilities
        this.updateInputStyles(inputElement, vulnerabilities);
        
        // Log detected vulnerabilities
        if (vulnerabilities.length > 0) {
            this.logVulnerability(value, vulnerabilities, inputElement);
        }
    }

    /**
     * Check input value against vulnerability patterns
     */
    checkVulnerabilities(value) {
        const detected = [];
        
        // Check XSS patterns
        if (this.vulnerabilityPatterns.xss.some(pattern => pattern.test(value))) {
            detected.push('xss');
        }
        
        // Check SQL Injection patterns
        if (this.vulnerabilityPatterns.sql.some(pattern => pattern.test(value))) {
            detected.push('sql');
        }
        
        // Check CSRF patterns
        if (this.vulnerabilityPatterns.csrf.some(pattern => pattern.test(value))) {
            detected.push('csrf');
        }
        
        return detected;
    }

    /**
     * Update input styles based on detected vulnerabilities
     */
    updateInputStyles(inputElement, vulnerabilities) {
        // Reset styles first
        this.resetInputStyles(inputElement);
        
        if (vulnerabilities.length === 0) return;
        
        // Add vulnerability class
        inputElement.classList.add('vulnerability-detected');
        
        // Add specific vulnerability classes
        vulnerabilities.forEach(type => {
            inputElement.classList.add(`vulnerability-${type}`);
        });
        
        // Add tooltip with vulnerability information
        this.addVulnerabilityTooltip(inputElement, vulnerabilities);
    }

    /**
     * Reset input styles
     */
    resetInputStyles(inputElement) {
        inputElement.classList.remove('vulnerability-detected', 'vulnerability-xss', 'vulnerability-sql', 'vulnerability-csrf');
        
        // Remove tooltip if exists
        const tooltip = inputElement.nextElementSibling;
        if (tooltip && tooltip.classList.contains('vulnerability-tooltip')) {
            tooltip.remove();
        }
    }

    /**
     * Add tooltip with vulnerability information
     */
    addVulnerabilityTooltip(inputElement, vulnerabilities) {
        // Remove existing tooltip if any
        const existingTooltip = inputElement.nextElementSibling;
        if (existingTooltip && existingTooltip.classList.contains('vulnerability-tooltip')) {
            existingTooltip.remove();
        }
        
        // Create tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'vulnerability-tooltip';
        
        // Add vulnerability information
        let tooltipContent = '<strong>Potential vulnerabilities detected:</strong><ul>';
        
        vulnerabilities.forEach(type => {
            let description = '';
            
            switch (type) {
                case 'xss':
                    description = 'Cross-Site Scripting (XSS) attempt detected. This input contains code that could execute in the browser.';
                    break;
                case 'sql':
                    description = 'SQL Injection attempt detected. This input contains SQL code that could manipulate the database.';
                    break;
                case 'csrf':
                    description = 'Cross-Site Request Forgery (CSRF) attempt detected. This input contains code that could perform unauthorized actions.';
                    break;
            }
            
            tooltipContent += `<li><strong>${type.toUpperCase()}:</strong> ${description}</li>`;
        });
        
        tooltipContent += '</ul>';
        tooltip.innerHTML = tooltipContent;
        
        // Insert tooltip after input
        inputElement.parentNode.insertBefore(tooltip, inputElement.nextSibling);
        
        // Position tooltip
        this.positionTooltip(inputElement, tooltip);
    }

    /**
     * Position tooltip relative to input
     */
    positionTooltip(inputElement, tooltip) {
        const inputRect = inputElement.getBoundingClientRect();
        
        tooltip.style.position = 'absolute';
        tooltip.style.left = `${inputRect.left}px`;
        tooltip.style.top = `${inputRect.bottom + 5}px`;
        tooltip.style.width = `${inputRect.width}px`;
        tooltip.style.zIndex = '1000';
    }

    /**
     * Log detected vulnerability
     */
    logVulnerability(input, vulnerabilities, inputElement) {
        // Get current page/section
        const currentPage = this.getCurrentPage();
        
        // Create log entry
        const logEntry = {
            timestamp: new Date().toISOString(),
            input: input,
            vulnerabilities: vulnerabilities,
            page: currentPage,
            element: inputElement.id || inputElement.name || 'unnamed-input'
        };
        
        // Log to console
        console.log('[VulnerabilityDetector] Detected:', logEntry);
        
        // Save to localStorage
        this.saveVulnerabilityLog(logEntry);
        
        // Update vulnerability counter
        this.updateVulnerabilityCounter(vulnerabilities);
        
        // Award points to user
        this.awardPointsForVulnerability(vulnerabilities);
        
        // Show notification
        this.showVulnerabilityNotification(vulnerabilities);
    }

    /**
     * Get current page/section name
     */
    getCurrentPage() {
        // Try to get from page title
        const title = document.title;
        if (title) {
            return title.split('-')[0].trim();
        }
        
        // Try to get from URL
        const path = window.location.pathname;
        const pathParts = path.split('/').filter(Boolean);
        
        if (pathParts.length > 0) {
            return pathParts[pathParts.length - 1].replace('.html', '');
        }
        
        return 'unknown';
    }

    /**
     * Save vulnerability log to localStorage
     */
    saveVulnerabilityLog(logEntry) {
        try {
            // Get existing logs
            const savedLogs = localStorage.getItem('seclab_vulnerability_logs');
            let logs = savedLogs ? JSON.parse(savedLogs) : [];
            
            // Add new log
            logs.unshift(logEntry);
            
            // Limit to 100 logs
            if (logs.length > 100) {
                logs = logs.slice(0, 100);
            }
            
            // Save back to localStorage
            localStorage.setItem('seclab_vulnerability_logs', JSON.stringify(logs));
            
            // Also save to security logs for dashboard
            this.saveToSecurityLogs(logEntry);
        } catch (error) {
            console.error('[VulnerabilityDetector] Error saving log:', error);
        }
    }

    /**
     * Save to security logs for dashboard
     */
    saveToSecurityLogs(logEntry) {
        try {
            // Get existing logs
            const savedLogs = localStorage.getItem('seclab_security_logs');
            let logs = savedLogs ? JSON.parse(savedLogs) : [];
            
            // Create security log entries for each vulnerability
            logEntry.vulnerabilities.forEach(type => {
                const securityLog = {
                    timestamp: logEntry.timestamp,
                    type: type,
                    source: logEntry.page,
                    details: `${type.toUpperCase()} attempt detected: ${this.truncateString(logEntry.input, 50)}`,
                    severity: type === 'xss' || type === 'sql' ? 'high' : 'medium'
                };
                
                logs.unshift(securityLog);
            });
            
            // Limit to 100 logs
            if (logs.length > 100) {
                logs = logs.slice(0, 100);
            }
            
            // Save back to localStorage
            localStorage.setItem('seclab_security_logs', JSON.stringify(logs));
        } catch (error) {
            console.error('[VulnerabilityDetector] Error saving security log:', error);
        }
    }

    /**
     * Update vulnerability counter
     */
    updateVulnerabilityCounter(vulnerabilities) {
        try {
            // Get counter from localStorage
            const savedCounter = localStorage.getItem('seclab_vulnerability_counter');
            if (!savedCounter) return;
            
            const counter = JSON.parse(savedCounter);
            
            // Update counter for each vulnerability type
            vulnerabilities.forEach(type => {
                if (counter[type] !== undefined) {
                    counter[type]++;
                    counter.total++;
                }
            });
            
            // Save back to localStorage
            localStorage.setItem('seclab_vulnerability_counter', JSON.stringify(counter));
            
            // Update dashboard data if available
            this.updateDashboardData(counter);
        } catch (error) {
            console.error('[VulnerabilityDetector] Error updating counter:', error);
        }
    }

    /**
     * Update dashboard data
     */
    updateDashboardData(counter) {
        try {
            // Get dashboard data from localStorage
            const savedData = localStorage.getItem('seclab_dashboard_data');
            if (!savedData) return;
            
            const data = JSON.parse(savedData);
            
            // Update stats
            if (data.stats) {
                data.stats.xss = counter.xss;
                data.stats.sql = counter.sql;
                data.stats.csrf = counter.csrf;
                data.stats.blocked = counter.total;
            }
            
            // Update timeline
            if (data.timeline) {
                // Get today's index (assuming timeline.labels is days of week)
                const today = new Date().getDay();
                const dayIndex = today === 0 ? 6 : today - 1; // Convert to 0-6 (Mon-Sun)
                
                if (data.timeline.data[dayIndex] !== undefined) {
                    data.timeline.data[dayIndex]++;
                }
            }
            
            // Save back to localStorage
            localStorage.setItem('seclab_dashboard_data', JSON.stringify(data));
        } catch (error) {
            console.error('[VulnerabilityDetector] Error updating dashboard data:', error);
        }
    }

    /**
     * Award points for detected vulnerabilities
     */
    awardPointsForVulnerability(vulnerabilities) {
        try {
            // Get student scores from localStorage
            const savedScores = localStorage.getItem('seclab_student_scores');
            if (!savedScores) return;
            
            const scores = JSON.parse(savedScores);
            let pointsAwarded = 0;
            
            // Award points for each vulnerability type
            vulnerabilities.forEach(type => {
                const points = this.scoreValues[type] || 5;
                pointsAwarded += points;
                
                // Update specific challenge score
                switch (type) {
                    case 'xss':
                        scores.xss = Math.min(100, scores.xss + points);
                        break;
                    case 'sql':
                        scores.sql = Math.min(100, scores.sql + points);
                        break;
                    case 'csrf':
                        scores.csrf = Math.min(100, scores.csrf + points);
                        break;
                }
            });
            
            // Update total score
            scores.total += pointsAwarded;
            
            // Save back to localStorage
            localStorage.setItem('seclab_student_scores', JSON.stringify(scores));
            
            // Show points notification
            if (pointsAwarded > 0) {
                this.showPointsNotification(pointsAwarded);
            }
        } catch (error) {
            console.error('[VulnerabilityDetector] Error awarding points:', error);
        }
    }

    /**
     * Show vulnerability notification
     */
    showVulnerabilityNotification(vulnerabilities) {
        // Check if SecurityUtils is available
        if (window.SecurityUtils) {
            const types = vulnerabilities.map(v => v.toUpperCase()).join(', ');
            window.SecurityUtils.showAlert(`ðŸš¨ ${types} vulnerability detected!`, 'danger');
        } else {
            // Fallback notification
            const types = vulnerabilities.map(v => v.toUpperCase()).join(', ');
            alert(`Vulnerability detected: ${types}`);
        }
    }

    /**
     * Show points notification
     */
    showPointsNotification(points) {
        // Check if SecurityUtils is available
        if (window.SecurityUtils) {
            window.SecurityUtils.showAlert(`ðŸŽ‰ +${points} points awarded!`, 'success');
        }
    }

    /**
     * Helper function to truncate string
     */
    truncateString(str, maxLength) {
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength) + '...';
    }
}

// Add CSS for vulnerability detection
const style = document.createElement('style');
style.textContent = `
    .vulnerability-detected {
        border-color: #ff0040 !important;
        box-shadow: 0 0 10px rgba(255, 0, 64, 0.3) !important;
    }
    
    .vulnerability-xss {
        background-color: rgba(255, 0, 64, 0.05) !important;
    }
    
    .vulnerability-sql {
        background-color: rgba(255, 170, 0, 0.05) !important;
    }
    
    .vulnerability-csrf {
        background-color: rgba(0, 128, 255, 0.05) !important;
    }
    
    .vulnerability-tooltip {
        background-color: #111111;
        color: #ffffff;
        padding: 10px;
        border-radius: 6px;
        border-left: 4px solid #ff0040;
        font-size: 12px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        margin-top: 5px;
        max-width: 400px;
    }
    
    .vulnerability-tooltip ul {
        margin: 5px 0;
        padding-left: 20px;
    }
    
    .vulnerability-tooltip li {
        margin-bottom: 5px;
    }
`;
document.head.appendChild(style);

// Initialize the detector when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.vulnerabilityDetector = new VulnerabilityDetector();
    
    // Re-initialize when new content is loaded
    const observer = new MutationObserver(() => {
        if (window.vulnerabilityDetector) {
            window.vulnerabilityDetector.addInputListeners();
        }
    });
    
    observer.observe(document.body, { childList: true, subtree: true });
});